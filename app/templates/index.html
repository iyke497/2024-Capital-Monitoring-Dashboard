{% extends "layout.html" %}

{% block title %}Survey Dashboard{% endblock %}
{% block header %}Data Ingestion Dashboard{% endblock %}

{% block content %}
<div class="controls">
    <div style="display: flex; align-items: center; gap: 15px;">
        <span id="last-updated" style="color: #666; font-size: 14px; font-weight: 500;">
            Last updated: Never
        </span>
        <span id="next-update" style="color: #999; font-size: 13px;">
            Next update in: --
        </span>
    </div>
    <div id="update-status" style="margin-top: 10px; padding: 8px 12px; background: #f0f0f0; border-radius: 4px; font-size: 13px; display: none;">
        <span id="status-icon">⏳</span>
        <span id="status-text">Updating...</span>
    </div>
</div>

<div class="stats-cards">
    <div class="card"><h3>Total</h3><div id="total-responses" class="stat-val">0</div></div>
    <div class="card"><h3>Survey 1</h3><div id="survey1-count" class="stat-val">0</div></div>
    <div class="card"><h3>Survey 2</h3><div id="survey2-count" class="stat-val">0</div></div>
</div>

<table id="responses-table" class="display" style="width:100%">
    <thead>
        <tr>
            <th>Project Name</th>
            <th>ERGP Code</th>
            <th>MDA</th>
            <th>% Done</th>
            <th>Appropriation</th>
        </tr>
    </thead>
</table>
{% endblock %}

{% block scripts %}
<script>
$(document).ready(function() {
    const POLL_INTERVAL = 60 * 60 * 1000; // 1 hour in milliseconds
    let nextUpdateTimer;
    let countdownInterval;
    
    // 1. Initialize DataTable
    const table = $('#responses-table').DataTable({
        serverSide: true,
        ajax: '/api/responses',
        columns: [
            { data: 'project_name', defaultContent: 'N/A' },
            { data: 'ergp_code', defaultContent: 'N/A' },
            { data: 'mda_name', defaultContent: 'N/A' },
            { data: 'percentage_completed', defaultContent: '0%' },
            { 
                data: 'project_appropriation_2024',
                render: $.fn.dataTable.render.number(',', '.', 2, '₦')
            }
        ]
    });

    // 2. Update last updated timestamp
    function updateLastUpdatedTime(date) {
        const timestamp = date || new Date();
        const timeString = timestamp.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
        const dateString = timestamp.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
        });
        $('#last-updated').text(`Last updated: ${dateString} at ${timeString}`);
    }

    // 3. Get server fetch status and sync countdown
    function syncWithServer() {
        $.get('/api/fetch/status', function(data) {
            if (data.last_fetch) {
                const lastFetch = new Date(data.last_fetch);
                updateLastUpdatedTime(lastFetch);
                
                // Calculate next update time based on server's last fetch
                nextUpdateTimer = lastFetch.getTime() + POLL_INTERVAL;
            } else {
                // No fetch has happened yet
                nextUpdateTimer = Date.now() + POLL_INTERVAL;
            }
            
            startCountdown();
        }).fail(function() {
            // Fallback if status endpoint fails
            console.warn('Could not sync with server, using local timer');
            nextUpdateTimer = Date.now() + POLL_INTERVAL;
            startCountdown();
        });
    }

    // 4. Countdown timer to next update
    function startCountdown() {
        clearInterval(countdownInterval);
        
        countdownInterval = setInterval(function() {
            const remaining = nextUpdateTimer - Date.now();
            
            if (remaining <= 0) {
                $('#next-update').text('Next update in: updating now...');
                return;
            }
            
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            
            if (minutes > 0) {
                $('#next-update').text(`Next update in: ${minutes}m ${seconds}s`);
            } else {
                $('#next-update').text(`Next update in: ${seconds}s`);
            }
        }, 1000);
    }

    // 4. Show/hide update status
    function showUpdateStatus(isUpdating, success = null) {
        const statusDiv = $('#update-status');
        const icon = $('#status-icon');
        const text = $('#status-text');
        
        if (isUpdating) {
            icon.text('⏳');
            text.text('Fetching latest data...');
            statusDiv.css('background', '#fff3cd').show();
        } else if (success === true) {
            icon.text('✓');
            text.text('Successfully updated!');
            statusDiv.css('background', '#d4edda').show();
            setTimeout(() => statusDiv.fadeOut(), 3000);
        } else if (success === false) {
            icon.text('⚠');
            text.text('Update failed - will retry next cycle');
            statusDiv.css('background', '#f8d7da').show();
            setTimeout(() => statusDiv.fadeOut(), 5000);
        }
    }

    // 5. Refresh Stats
    function updateStats() {
        $.get('/api/stats', function(data) {
            $('#total-responses').text(data.total_responses);
            $('#survey1-count').text(data.survey1_count);
            $('#survey2-count').text(data.survey2_count);
        });
    }

    // 7. Automatic polling function
    function autoFetchAllSurveys() {
        console.log('Auto-fetching surveys...');
        showUpdateStatus(true);

        $.post('/api/fetch/all', function(res) {
            console.log('Auto-fetch successful:', res.message);
            table.ajax.reload();
            updateStats();
            
            // Update with server's timestamp
            if (res.fetched_at) {
                const fetchTime = new Date(res.fetched_at);
                updateLastUpdatedTime(fetchTime);
                nextUpdateTimer = fetchTime.getTime() + POLL_INTERVAL;
            } else {
                updateLastUpdatedTime();
                nextUpdateTimer = Date.now() + POLL_INTERVAL;
            }
            
            showUpdateStatus(false, true);
            startCountdown();
        })
        .fail(function(xhr) {
            const response = xhr.responseJSON;
            
            // Handle gracefully if another user is already fetching
            if (response?.in_progress) {
                console.log('Another user is fetching data, skipping...');
                $('#status-text').text('Another user is updating data...');
                showUpdateStatus(false, null);
            } 
            // Handle cooldown period
            else if (response?.cooldown) {
                console.log('Cooldown active:', response.message);
                $('#status-text').text('Data recently updated');
                showUpdateStatus(false, null);
                
                // Sync with server's next available time
                if (response.next_available) {
                    nextUpdateTimer = new Date(response.next_available).getTime();
                    startCountdown();
                }
            }
            // Actual error
            else {
                console.error('Auto-fetch failed:', response?.message || 'Unknown error');
                showUpdateStatus(false, false);
            }
            
            startCountdown();
        });
    }

    // 8. Initial load - sync with server first
    updateStats();
    syncWithServer(); // This will set the correct countdown and last updated time

    // 9. Set up automatic polling every hour
    setInterval(autoFetchAllSurveys, POLL_INTERVAL);
    
    // 10. Optional: Fetch on initial page load
    // Uncomment the line below to fetch data when page first loads
    // autoFetchAllSurveys();
});
</script>
{% endblock %}